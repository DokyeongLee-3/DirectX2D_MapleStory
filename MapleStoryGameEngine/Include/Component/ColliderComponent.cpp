
#include "ColliderComponent.h"
#include "../Scene/Scene.h"
#include "../Scene/SceneCollision.h"
#include "../Collision/CollisionManager.h"
#include "../Resource/Shader/ColliderConstantBuffer.h"

CColliderComponent::CColliderComponent()
{
	SetTypeID<CColliderComponent>();
	m_ComponentType = Component_Type::SceneComponent;
	m_Render = true;

	m_CurrentSectionCheck = false;
	m_Profile = nullptr;
	m_MouseCollision = false;
	m_Mesh = nullptr;
	m_CBuffer = nullptr;
}

CColliderComponent::CColliderComponent(const CColliderComponent& com) :
	CSceneComponent(com)
{
	m_MouseCollision = false;
	m_CurrentSectionCheck = false;
	m_Render = com.m_Render;
	m_Profile = com.m_Profile;
	m_CBuffer = com.m_CBuffer->Clone();
	m_Mesh = com.m_Mesh;
	m_Shader = com.m_Shader;
}

CColliderComponent::~CColliderComponent()
{
	SAFE_DELETE(m_CBuffer);

	auto	iter = m_PrevCollisionList.begin();
	auto	iterEnd = m_PrevCollisionList.end();

	for (; iter != iterEnd; ++iter)
	{
		(*iter)->CallCollisionCallback(Collision_State::End);
		CallCollisionCallback(Collision_State::End);
		(*iter)->DeletePrevCollision(this);


		// 나는 이제 제거되니 나랑 충돌됐던 대상에게 m_Result에 나를 설정해놓지 말라고한다
		(*iter)->m_Result.Dest = nullptr;
		
	}
}

void CColliderComponent::SetCollisionProfile(const std::string& Name)
{
	m_Profile = CCollisionManager::GetInst()->FindProfile(Name);
}

void CColliderComponent::CheckPrevColliderSection()
{
	auto	iter = m_PrevCollisionList.begin();
	auto	iterEnd = m_PrevCollisionList.end();

	// 이전프레임에 충돌되었던 충돌체들을 반복하며 하나라도 겹치는 Section이 있는지 확인한다
	// 만약 이전프레임에 충돌이 되었는데 현재 겹치는 Section이 하나도 없다면 해당 충돌체와는 충돌 가능성이
	// 없으므로 충돌되었다가 떨어진것이다
	for (; iter != iterEnd;)
	{
		bool	Check = false;

		// 충돌영역을 체크한다.
		size_t	Size = m_vecSectionIndex.size();

		for (size_t i = 0; i < Size; ++i)
		{
			size_t	DestSize = (*iter)->m_vecSectionIndex.size();

			for (size_t j = 0; j < DestSize; ++j)
			{
				if (m_vecSectionIndex[i] == (*iter)->m_vecSectionIndex[j])
				{
					Check = true;
					break;
				}
			}

			if (Check)
				break;
		}

		// 서로 겹치는 충돌영역이 없으므로 붙어있다가 떨어지는 것이다.
		if (!Check)
		{
			CColliderComponent* SrcResultDestComp = m_Result.Dest;
			CColliderComponent* DestResultDestComp = (*iter)->GetCollisionResult().Dest;

			// 이전 iteration에서 A와 B가 충돌해서 각각의 m_Result에 서로를 설정해놓고 다음 iteration에서 A와 C와 충돌 검사를 해보니
			// 이제 막 떨어진 경우라서 여기 else if로 들어왔을때 A의 m_Result.Dest는 B가 설정되어있을건데 여기서 그냥
			// CollisionEnd의 콜백을 호출하면 A의 m_Result.Dest에는 여전히 B가 들어가있어서 CollisionEnd인자로도 Result.Dest를 B로 넘겨줄것이므로
			// 그건 잘못된 것이므로 CollisionEnd 호출시에 이제 막 떨어지는 대상을 인자로 넣어주고 CollisionEnd 콜백이 끝나면 원상복귀 시켜준다
			if (m_Result.Dest != (*iter))
			{
				m_Result.Dest = *iter;
			}

			if ((*iter)->GetCollisionResult().Dest != this)
			{
				(*iter)->SetDestCollisionResult(this);
			}

			CallCollisionCallback(Collision_State::End);
			(*iter)->CallCollisionCallback(Collision_State::End);

			// 원상복구
			m_Result.Dest = SrcResultDestComp;
			(*iter)->SetDestCollisionResult(DestResultDestComp);

			// 서로 이전 충돌목록에서 제거해준다.
			(*iter)->DeletePrevCollision(this);

			iter = m_PrevCollisionList.erase(iter);
			iterEnd = m_PrevCollisionList.end();
			continue;
		}

		++iter;
	}
}

void CColliderComponent::AddPrevCollision(CColliderComponent* Collider)
{
	m_PrevCollisionList.push_back(Collider);
}

void CColliderComponent::DeletePrevCollision(CColliderComponent* Collider)
{
	auto	iter = m_PrevCollisionList.begin();
	auto	iterEnd = m_PrevCollisionList.end();

	for (; iter != iterEnd; ++iter)
	{
		if (*iter == Collider)
		{
			m_PrevCollisionList.erase(iter);
			return;
		}
	}
}

bool CColliderComponent::EmptyPrevCollision()
{
	return m_PrevCollisionList.empty();
}

bool CColliderComponent::CheckPrevCollision(CColliderComponent* Collider)
{
	auto	iter = m_PrevCollisionList.begin();
	auto	iterEnd = m_PrevCollisionList.end();

	for (; iter != iterEnd; ++iter)
	{
		if (*iter == Collider)
			return true;
	}

	return false;
}

bool CColliderComponent::CheckPrevCollisionGameObjectType(size_t TypeID)
{
	auto	iter = m_PrevCollisionList.begin();
	auto	iterEnd = m_PrevCollisionList.end();

	for (; iter != iterEnd; ++iter)
	{
		if ((*iter)->GetGameObject()->GetTypeID() == TypeID)
			return true;
	}

	return false;
}

bool CColliderComponent::CheckCurrentFrameCollision(CColliderComponent* Collider)
{
	auto	iter = m_CurrentCollisionList.begin();
	auto	iterEnd = m_CurrentCollisionList.end();

	for (; iter != iterEnd; ++iter)
	{
		if (*iter == Collider)
			return true;
	}

	return false;
}

void CColliderComponent::AddCurrentFrameCollision(CColliderComponent* Collider)
{
	if (!CheckCurrentFrameCollision(Collider))
		m_CurrentCollisionList.push_back(Collider);
}

void CColliderComponent::CallCollisionCallback(Collision_State State)
{
	auto	iter = m_CollisionCallback[(int)State].begin();
	auto	iterEnd = m_CollisionCallback[(int)State].end();

	for (; iter != iterEnd; ++iter)
	{
		(*iter)(m_Result);
	}
}

void CColliderComponent::CallCollisionMouseCallback(Collision_State State)
{
	if (State == Collision_State::End)
		m_MouseCollision = false;

	auto	iter = m_CollisionMouseCallback[(int)State].begin();
	auto	iterEnd = m_CollisionMouseCallback[(int)State].end();

	for (; iter != iterEnd; ++iter)
	{
		(*iter)(m_MouseResult);
	}
}

void CColliderComponent::ClearFrame()
{
	m_vecSectionIndex.clear();
	m_CurrentCollisionList.clear();
	m_CurrentSectionCheck = false;
}

void CColliderComponent::Start()
{
	CSceneComponent::Start();

	// CColliderComponent::Start이 두번 호출되고 있음
	m_Scene->GetCollision()->AddCollider(this);
}

bool CColliderComponent::Init()
{
	if (!CSceneComponent::Init())
		return false;

	SetCollisionProfile("Object");

	m_CBuffer = new CColliderConstantBuffer;

	m_CBuffer->Init();

	m_CBuffer->SetColliderColor(Vector4(0.f, 1.f, 0.f, 1.f));

	m_Shader = CResourceManager::GetInst()->FindShader("ColliderShader");

	return true;
}

void CColliderComponent::Update(float DeltaTime)
{
	CSceneComponent::Update(DeltaTime);
}

void CColliderComponent::PostUpdate(float DeltaTime)
{
	CSceneComponent::PostUpdate(DeltaTime);
}

void CColliderComponent::CheckCollision()
{
	CSceneComponent::CheckCollision();
}

void CColliderComponent::PrevRender()
{
	CSceneComponent::PrevRender();
}

void CColliderComponent::Render()
{
	CSceneComponent::Render();
}

void CColliderComponent::PostRender()
{
	CSceneComponent::PostRender();
}

CColliderComponent* CColliderComponent::Clone()
{
	return nullptr;
}

void CColliderComponent::Save(FILE* File)
{
	CSceneComponent::Save(File);

	std::string	MeshName = m_Mesh->GetName();

	int	Length = (int)MeshName.length();

	fwrite(&Length, sizeof(int), 1, File);
	fwrite(MeshName.c_str(), sizeof(char), Length, File);

	std::string	ShaderName = m_Shader->GetName();

	Length = (int)ShaderName.length();

	fwrite(&Length, sizeof(int), 1, File);
	fwrite(ShaderName.c_str(), sizeof(char), Length, File);

	fwrite(&m_ColliderType, sizeof(Collider_Type), 1, File);
	fwrite(&m_Offset, sizeof(Vector3), 1, File);
	fwrite(&m_Min, sizeof(Vector3), 1, File);
	fwrite(&m_Max, sizeof(Vector3), 1, File);

	// 추가한 부분
	std::string ProfileName = m_Profile->Name;
	Length = (int)ProfileName.length();

	fwrite(&Length, sizeof(int), 1, File);
	fwrite(ProfileName.c_str(), sizeof(char), Length, File);
}

void CColliderComponent::Load(FILE* File)
{
	CSceneComponent::Load(File);

	char	MeshName[256] = {};

	int	Length = 0;

	fread(&Length, sizeof(int), 1, File);
	fread(MeshName, sizeof(char), Length, File);

	m_Mesh = (CMesh*)m_Scene->GetResource()->FindMesh(MeshName);

	char	ShaderName[256] = {};

	Length = 0;

	fread(&Length, sizeof(int), 1, File);
	fread(ShaderName, sizeof(char), Length, File);

	m_Shader = m_Scene->GetResource()->FindShader(ShaderName);

	m_Mesh = (CMesh*)m_Scene->GetResource()->FindMesh(MeshName);

	m_CBuffer = CreateEmptyBuffer<CColliderConstantBuffer>();

	fread(&m_ColliderType, sizeof(Collider_Type), 1, File);
	fread(&m_Offset, sizeof(Vector3), 1, File);
	fread(&m_Min, sizeof(Vector3), 1, File);
	fread(&m_Max, sizeof(Vector3), 1, File);

	// 추가한 부분
	char ProfileName[256] = {};

	fread(&Length, sizeof(int), 1, File);
	fread(ProfileName, sizeof(char), Length, File);

	SetCollisionProfile(ProfileName);
}
